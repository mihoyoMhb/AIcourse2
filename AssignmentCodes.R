#' The code implementation of this assignment was developed collaboratively by 
#' our group and is hosted on GitHub. The repository link is: 
#' https://github.com/mihoyoMhb/AIcourse2
#' Group members:
#' Hangbiao Meng
#' Yuanjing Yang
#' Linjia Zhong
EmissionMatrix = function(readings, probs){
  #' Readings includes the data returned from the second sensor.
  #' reading[1] = salinity
  #' reading[2] = phosphate
  #' reading[3] = nitrogen
  #' probs was generated by given code we just use it manually
  # If a readings is given, we can calculate the probabilities of every holes giving the data
  # 40 holes
  salinity = dnorm(readings[1], probs$salinity[,1], probs$salinity[,2], log = FALSE)
  phosphate = dnorm(readings[2], probs$phosphate[,1], probs$phosphate[,2], log = FALSE)
  nitrogen = dnorm(readings[3], probs$nitrogen[,1], probs$nitrogen[,2], log = FALSE)
  emission = salinity * phosphate * nitrogen
  emission = emission / sum(emission)
  return (emission)
}

computeTransitionMatrix = function(edges){
  N = 40
  # The transition matrix
  P = matrix(0, nrow = N, ncol = N)
  
  # The list of neighboring nodes for each node.
  neighbors_list = vector("list", N)
  
  for (j in 1:N){
    # Transfer from j its self and neighborhoods
    options_j = getOptions(j, edges)
    # As we can see, it is a uniform distribution
    num_options = length(options_j)
    prob = 1 / num_options
    # It is a conditional probability, means transform from j to possible neighbors
    # as well as it self.
    P[options_j, j] = prob
    # The list of neighbors for node j is stored in the neighbors_list at index 
    # j, so we can use them later, avoiding call method getOptions too many times.
    neighbors_list[[j]] = options_j
  }
  return(list(P = P, neighbors = neighbors_list))
}

UpdateAlpha = function(alpha_prev, P, emission_matrix){
  # Matrix explaination: P * alpha_prev means transfer from the previous node(i|i-1)
  alpha_curr = (P %*% alpha_prev) * emission_matrix
  return(as.vector(alpha_curr))
}

# HMM core function
HMM = function(alpha_pre, probs, readings, positions, P){
  tourist1 = positions[1]
  tourist2 = positions[2]
  my_position = positions[3]
  
  alpha_curr = numeric(40)
  # The first 2 if, means someone was eaten and we immediately know where the
  # worm is.
  if (!is.na(tourist1) && tourist1 < 0){
    croc_position = -tourist1
    alpha_curr[croc_position] = 1
  } else if (!is.na(tourist2) && tourist2 < 0){
    croc_position = -tourist2
    alpha_curr[croc_position] = 1
  } else {
    emission_matrix = EmissionMatrix(readings, probs)
    alpha_curr = UpdateAlpha(alpha_pre, P, emission_matrix)
    alpha_curr = alpha_curr / sum(alpha_curr)
  }
  return(alpha_curr)
}

#' bfsSearch maybe can be change to another type
#' Source: Bodin, E. (n.d.). *Where's Croc? [R Script]*. 
#' GitHub. https://rdrr.io/github/emanuelbodin/wheresCroc/src/R/WheresCroc.R

bfsSearch = function(startNode, goalNode, neighbors) {
  visited = rep(FALSE, 40)
  queue = c(startNode)
  parents = rep(NA, 40)
  visited[startNode] = TRUE
  
  while (length(queue) > 0) {
    currentNode = queue[1]
    queue = queue[-1]
    
    if (currentNode == goalNode) {
      break
    }
    
    neighbors_current = neighbors[[currentNode]]
    
    for (neighbor in neighbors_current) {
      if (!visited[neighbor]) {
        visited[neighbor] = TRUE
        parents[neighbor] = currentNode
        queue = c(queue, neighbor)
      }
    }
  }
  
  path = c()
  currentNode = goalNode
  while (!is.na(currentNode) && currentNode != startNode) {
    path = c(currentNode, path)
    currentNode = parents[currentNode]
  }
  
  if (is.na(currentNode)) {
    return(integer(0))
  } else {
    return(path)
  }
}

# myFunction 
myFunction = function(moveInfo, readings, positions, edges, probs) {
  me = positions[3]
  status = moveInfo[["mem"]][["status"]]
  #' computeTransitionMatrix(edges) above is called to create P (transition matrix) 
  #' and neighbors (list of neighbors for each node)
  if (is.null(moveInfo[["mem"]][["P"]])) {
    trans_data = computeTransitionMatrix(edges)
    P = trans_data$P
    neighbors = trans_data$neighbors
    moveInfo[["mem"]][["P"]] = P
    #' Important, we have created the neighbors information before, so we
    #' can save it to mem, which should speed up the time.
    moveInfo[["mem"]][["neighbors"]] = neighbors
  } else {
    P = moveInfo[["mem"]][["P"]]
    neighbors = moveInfo[["mem"]][["neighbors"]]
  }
  
  
  if (status == 0 || status == 1) {
    prev_f = rep(1, 40)
    # AT first, the corc should not be with tourists
    if (!is.na(positions[1]) && positions[1] > 0){
      prev_f[positions[1]] = 0
    }
    if (!is.na(positions[2]) && positions[2] > 0){
      prev_f[positions[2]] = 0
    }
    prev_f = prev_f / sum(prev_f)
    moveInfo[["mem"]][["prev_f"]] = prev_f
  }
  
  prev_f = moveInfo[["mem"]][["prev_f"]]
  new_f = HMM(prev_f, probs, readings, positions, P)
  goal = which.max(new_f)
  
  neighbors_me = neighbors[[me]]
  # The croc is there, catch it!
  if (goal == me) {
    # me with croc
    moveInfo$moves = c(0, 0)
  } else if (goal %in% neighbors_me) {
    # croc is next to me 
    moveInfo$moves = c(goal, 0)
  } else {
    path = bfsSearch(me, goal, neighbors)
    if (length(path) >= 2) {
      moveInfo$moves = c(path[1], path[2])
    } else if (length(path) == 1){
      moveInfo$moves = c(path[1], 0)
    } else {
      moveInfo$moves = c(0, 0)
    }
  }
  
  moveInfo[['mem']][["prev_f"]] = new_f
  moveInfo[["mem"]][["status"]] = 2 # Game is running
  
  return(moveInfo)
}
